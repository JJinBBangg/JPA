1. 학습내용
 - JPA 개요
  1)sql 중심의 개발에서 객체중심의 개발
  2) 생산성
  3) 유지보수
  4) 패러다임 불일치 해소

 - EntityManagerFactory  persistence nuit 기본 커넥션 DB 스키마와 1:1로 매칭
 - EntityManager 1개 connection풀 생성(절대 공유되지않게하고 사용한는 곳 지정) 사용후 반드시 반환
 - EntityTransaction 쿼리 만들어서 실행시킬 1개 단위 생성

 - 영속성 컨텍스트 개념
   entityManager 
   1. 내부 1차 캐시 <- 영속성 컨텍스트로 이해해도됨  (db에 있는 키값과 value(Entity))
   2. find 하게되면 우선적으로 1차캐시를 찾아보게됨
   3. 없으면 db에서 검색한 키값을 찾아서 값을 불러오고
     4. 1차캐시에 저장하게됨
    * 이점이 크게 있어보이지 않는 것이 entitymanager는 1개 트렌젝션이 생성되었다 끝나는시점에 삭제하기때문에 
    1개 비지니스로직이 끝나면 제거함

  기본적으로 jpa에서는 autocommit 옵션이 false인 것을 기본으로하여
    update 같은경우 영속성 컨텍스트에 저장된 값을 변경하게되면(영속성컨텍스트에 persist로 값을 입력한 경우, 삭제인경우 em.remove 되면서 없어지게되면 변경값을 감지)  
  flush 발생 시 최초에  불러왔던 snapshot을 기준으로 변경값이 있을 때 그에 맞는 쿼리문을 작성하고 쓰기 지연 sql문을 작성 (db에서 영구저장되는것이 아니라 sql문이 생성되는 것까지)
    이후 commit() 실행 시 영구적으로 db에 반영
    변경된 값이 있을 시 update 쿼리를 날리게 됨
    영속성컨텍스트에 저장된 값만 변경하고 commit 해야함 (별도로 update 로직을 작성하지 않아도됨 않아야함!)