1. 학습내용
 - 스프링 부트 + JPA 활용 (쇼핑몰)
  1. 프로젝트 세팅 및 도메인 분석 
  2. 테이블 및 엔티티설계
  3. 요구사항분석
회원기능 
 1. 등록 
 2. 조회
상품기능
  1. 등록
  2. 수정
  3. 조회
주문기능
  1. 주문
  2. 내역조회
  3. 취소

   4. 어플리캐이션 아키텍쳐
  <계층형구조>
 - controller, web: 웹 계층
 - service: 비지니스 로직, 트렌젝션 처리
 - repository: JPA를 직접 사용하는 계층, 엔티티 매니저 사용
 - domain: 엔티티를 모아두는 계층, 모든 계층에서 사용

각각(Entity, Repository, Service, Test코드)
회원, 상품, 주문 도메인 개발

Web 계층 개발 시 

JPA 변경감지
	1차 캐시인 영속성컨텍스트에 식별자가 확인된 객체를 등록해놓고 객체의 내용을 변경할 시 commit시점에 변경된 값을 감지하여 변경된 내용만 update쿼리를 날리게 됨

JPA 병합사용 ( 실무에서는 아주 간단하거나 데이터가 복잡하지 않고 변경값을 필수로 입력해야하는 상황에서만 사용하는 것을 권장하기 때문에 왠만해서는 사용하는 것을 권장하지 않음)
	em.merge() 를 사용하여 영속성 컨텍스트로 등록되어있지 않지만 
	식별자(id) 값을 가지고있는 경우 해당 내용 모두를(해당 컬럼의 내용과 변경사항 비교하지않음) 통째로 해당 식별자 객체에 넣고 영속성컨텍스트에 등록함
	통째로 교체하기 때문에 위험할 수 있음 ( 컬럼의 값들 중 기존에 값이 있었으나 merge하는 내용에 null값을 가지고있으면 기존 데이터를 null로 변경시켜버릴 수 있음 )
	commit 시점에 upadate쿼리를 날리게 됨

API개발 시 유의 사항
//    private static class Result<T>{
//        private T data;
//        private int count;
//    }

//    단건을 응답하는 api 인 경우 객체의 이름이 바로 api 스펙으로 전달되어도 확장에 어려움이 없지만
//    List 를 바로 응답할 경우 Array 로 json 을 반환하게됨
//    api 응답할 때 List인 경우 위처럼 감싸고난 후 내보내면 data 라는 객체 내부에 List내용이 배열로 나가기때문에
//    api 스팩 상 추가적인 내용을 json 객체로 전달 하는데 api스펙 수정은없고 확장성있게 유연한 대처를 할 수 있음
    
//    {[
//        {
//              name : "member1"
//        },
//        {
//              name : "member2"
//        },
//    ]}

    // Data로 감싼 후 응답할 시 List<Member> 가 Array 아니라 객체 내부의 배열로 인식되어
    // count 처럼 여러 값을 추가로 넣는다고 해도 api 스펙상 확장된거지 수정된게 아니게 됨

//    private static class Result<T>{
//        private T data;
//        private int count;
//    }

//    {
//          "count" : 2,  //count 를 추가하는 등 기존 api 스팩에 관여하지 않고 추가로 객체전달 가능
//          "data" :[
//              {
//                   name : "member1"
//              },
//                   name : "member2"
//              {
//          ]
//    }
//


성능에 관여할 수 있는 요소 정리(JPA 쿼리 튜닝)
1. 테이블 생성 전략 - 조인, 단일테이블, 구현클레스마다구현
2. 기본값 : @XXXToOne(fetch = FetchType.EAGER), @XXXToMany(fetch = FetchType.LAZY) 
   -LAZY(지연로딩) , EAGER(즉시로딩) : LAZY사용을 권장하며 
3. 양방향 연관관계 설정(로직의 연관성을 분석하여 관계의 주인설정) - 착안사항 연관관계의 설정이 잘못되어 불필요한 쿼리가 실행되는경우 성능저하
4. 2번과 관련되어있으나 jpql사용할 때 1차캐시에 없는데이터 사용하는경우 사용할 때마다 가져오는 것이 성능에 관련 있을 수 있으니
    필요한 경우 JPQL의 join fetch기능을 사용하여 한번에 영속성 컨텍스트에 값을 저장하고 사용(EAGER사용은 지양), 엔티티 그래프 기능 사용

api 개발 시 발생하는 문제점 실습
1. 조회용 샘플 데이터 입력
2. 지연로딩과 조회성능 최적화
3. 컬렉션 조회 최적화
4. 페이징과 한계 돌파
5. OSIV와 성능 최적화 